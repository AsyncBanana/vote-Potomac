---
import AppLayout from "../layouts/AppLayout.astro";
import { verifyJWT } from "../modules/auth";
import { FoodLocation, Suggestions } from "../schemas/suggestion";
import { Users } from "../schemas/user";
import { desc, eq } from "drizzle-orm";
import Button from "../components/Button.svelte";
import { notifications } from "../modules/notification";
import SuggestionsViewer from "../components/SuggestionsViewer.astro";
import { ContentStatus } from "../types/SharedContent";
import FoodForm from "../fragments/FoodForm.svelte";
import ImageStarGrid from "../components/ImageStarGrid.svelte";
export const prerender = false;
let id;
const authData = Astro.cookies.get("authData")?.value;
if (authData) {
	id = await verifyJWT(Astro.locals.runtime.env, authData);
}
const sortOrder = Astro.url.searchParams.get("sort") || "top";
const [suggestions, userData] = await Astro.locals.db.batch([
	Astro.locals.db
		.select({
			id: Suggestions.id,
			title: Suggestions.title,
			voteCount: Suggestions.voteCount,
			votes: Suggestions.votes,
			downvotes: Suggestions.downvotes,
			metadata: Suggestions.metadata,
		})
		.from(Suggestions)
		.limit(30)
		.orderBy(desc(sortOrder === "top" ? Suggestions.voteCount : Suggestions.id))
		.where(eq(Suggestions.status, ContentStatus.FoodActive)),
	...(id
		? [
				Astro.locals.db
					.select()
					.from(Users)
					.where(eq(Users.id, id || "")),
			]
		: []), // the lengths I go to avoid naming things
]);
const res = await Astro.locals.handle(
	userData ? { userData: userData[0] } : {}
);
if (res.type === "error") return res.data;
const notification = Astro.cookies.get("notification")?.value as
	| keyof typeof notifications
	| undefined;
if (notification) {
	Astro.cookies.delete("notification");
}
---

<AppLayout {...res.data} theme="light" newSuggestionButton={false}>
	<div class="flex flex-col gap-3 mt-3 w-main">
		{
			notification && (
				<div class="alert" id="notification">
					<span class="i-ic:round-check" />
					<span>{notifications[notification]}</span>
					<div>
						<Button
							type="tertiary"
							icon="i-ic:round-close"
							on:click={() => document.getElementById("notification")?.remove()}
							client:load
						/>
					</div>
				</div>
			)
		}
		<div class="h-[50vh] w-full">
			<h1 class="font-black text-7xl text-center">Let's get better snacks</h1>
			<div class="grid grid-cols-3 gap-1 w-max m-auto">
				<ImageStarGrid
					items={[
						["Vending Machine", "/images/vending.avif", FoodLocation.vending],
						["Breakfast Bar", "/images/breakfast.avif", FoodLocation.breakfast],
						["Panther Pit", "/images/pantherpit.avif", FoodLocation.pantherpit],
					]}
					client:load
				/>
			</div>
		</div>
		<Button
			href={userData?.[0]
				? "#submit"
				: `/api/auth/signin?redirectURL=${encodeURIComponent("/food#submit")}`}
			className="w-min block">Submit New</Button
		>
		<select class="select select-bordered w-max" id="sort">
			<option selected={sortOrder === "recent"} value="recent"
				>Most recent</option
			>
			<option selected={sortOrder === "top"} value="top">Most votes</option>
		</select>
		<div id="suggestions" class="flex flex-col gap-3">
			<SuggestionsViewer
				id={userData?.[0]?.id}
				suggestions={suggestions}
				loadAdditional={suggestions.length === 30}
			/>
		</div>
	</div>
	<FoodForm client:load />
</AppLayout>
<!-- // BUG: will not work without global -->
<style is:global>
	:is(.ci-vending, .ci-breakfast, .ci-pantherpit) {
		&::before {
			width: 32px;
			height: 32px;
			background-position: center;
			background-size: contain;
			background-repeat: no-repeat;
			content: "";
		}
		&:checked {
			@apply !bg-secondary;
		}
	}
	.ci-vending::before {
		background-image: url("/images/vending.avif");
	}
	.ci-breakfast::before {
		background-image: url("/images/breakfast.avif");
	}
	.ci-pantherpit::before {
		background-image: url("/images/pantherpit.avif");
	}
</style>
<script>
	async function querySearch(
		// q is unused as of now
		q: "" = "",
		sort: string = sortEl.options[sortEl.selectedIndex].value,
		pushstate: boolean = true
	) {
		const queryParams = new URLSearchParams();
		if (q) queryParams.append("q", q);
		if (sort) queryParams.append("sort", sort);
		if (window.foodLocation)
			queryParams.append("location", window.foodLocation);
		const res = await fetch(
			`/api/suggestions?food${
				queryParams.size > 0 ? `&${queryParams.toString()}` : ""
			}`
		);
		const text = await res.text();
		if (text === "No suggestions found") {
			suggestions.innerHTML = "No suggestions found :(";
			return;
		}
		if (!res.ok) return;
		suggestions.innerHTML = text;
		if (pushstate)
			history.pushState(
				{ q, sort },
				"",
				queryParams.size > 0 ? `/food?${queryParams.toString()}` : "/"
			);
	}
	const suggestions = document.getElementById("suggestions") as HTMLDivElement;
	const sortEl = document.getElementById(
		"sort"
	) as unknown as HTMLSelectElement;
	addEventListener("popstate", async (event) => {
		// search.value = event.state.q;
		await querySearch(event.state.q, event.state.sort, false);
	});
	sortEl.addEventListener("change", async (e) => {
		await querySearch();
	});
	let offset = 30;
	window.querySearch = querySearch;
	// @ts-expect-error trust guys not using a js framework was a great idea
	window.loadSuggestions = async () => {
		const res = await fetch(
			`/api/suggestions?offset=${offset}&sort=${new URLSearchParams(document.location.search).get("sort") || "top"}&food${window.foodLocation ? `&location=${window.foodLocation}` : ""}`
		);
		offset += 30; // if the suggestion count is not 30, this will not matter
		suggestions.insertAdjacentHTML("beforeend", await res.text());
	};
</script>
